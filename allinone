import requests
import pandas as pd
import os
import datetime
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

# -------------------- CONFIGURATIONS --------------------
# JIRA API
JIRA_URL = "https://jira.crm.com/rest/api/search?jql="
JIRA_TOKEN = "jskdjdjd"

# DefectDojo API
DOJO_URL = "https://dojo.crm.com/api/v2/engagements"
DOJO_TOKEN = "jsjdjjd"

# SMTP Email Settings
SMTP_SERVER = "smtp.aws.india.east"
SMTP_USERNAME = "dndjdj"
SMTP_PASSWORD = "dndjdn"
SENDER_EMAIL = "crm@dojo.com"
SENDER_NAME = "Crm"
TO_EMAILS = ["abc@gmail.com", "def@gmail.com"]
CC_EMAILS = ["ghj@gmail.com", "djdjd@gmail.com"]

# Data Storage Paths
DATA_HTML_FOLDER = "data/html"
DATA_EXCEL_FOLDER = "data/excels"
MERGED_EXCEL_FOLDER = "data/Merged"

# Ensure Directories Exist
os.makedirs(DATA_HTML_FOLDER, exist_ok=True)
os.makedirs(DATA_EXCEL_FOLDER, exist_ok=True)
os.makedirs(MERGED_EXCEL_FOLDER, exist_ok=True)

# -------------------- STEP 1: USER INPUT --------------------
# Prompt user for versions
versions = input("Enter versions (comma-separated): ").split(",")
versions = [v.strip() for v in versions]

# -------------------- STEP 2: FETCH JIRA DATA --------------------
def fetch_jira_count(jql):
    headers = {"Authorization": f"Bearer {JIRA_TOKEN}"}
    response = requests.get(f"{JIRA_URL}{jql}", headers=headers)
    return response.json().get("total", 0) if response.status_code == 200 else 0

# -------------------- STEP 3: GENERATE HTML REPORT --------------------
for version in versions:
    jql1 = f"labels in ({version}) OR Build(s) in ({version})"
    jql2 = f"{jql1} AND component in (Security)"
    
    count1 = fetch_jira_count(jql1)
    count2 = fetch_jira_count(jql2)

    html_content = f"""
    <html>
    <body>
        <h2>Version Details: {version}</h2>
        <table border="1">
            <tr><th>JQL</th><th>Count</th></tr>
            <tr><td>{jql1}</td><td>{count1}</td></tr>
            <tr><td>{jql2}</td><td>{count2}</td></tr>
        </table>
    </body>
    </html>
    """
    with open(f"{DATA_HTML_FOLDER}/{version}.html", "w") as f:
        f.write(html_content)

# -------------------- STEP 4: EMAIL HTML REPORT --------------------
def send_email(version, assigned_user_email):
    msg = MIMEMultipart()
    msg["From"] = SENDER_NAME
    msg["To"] = f"{','.join(TO_EMAILS)},{assigned_user_email}"
    msg["Cc"] = ",".join(CC_EMAILS)
    msg["Subject"] = version

    file_path = f"{DATA_HTML_FOLDER}/{version}.html"
    with open(file_path, "rb") as attachment:
        part = MIMEBase("application", "octet-stream")
        part.set_payload(attachment.read())
    encoders.encode_base64(part)
    part.add_header("Content-Disposition", f"attachment; filename={version}.html")
    msg.attach(part)

    with smtplib.SMTP(SMTP_SERVER, 587) as server:
        server.starttls()
        server.login(SMTP_USERNAME, SMTP_PASSWORD)
        server.sendmail(SENDER_EMAIL, TO_EMAILS + CC_EMAILS, msg.as_string())

for version in versions:
    assigned_user_email = f"{version}@crm.com"  # Fetch dynamically if needed
    send_email(version, assigned_user_email)
    print(f"✅ Email sent for version {version}")

# -------------------- STEP 5: FETCH & PROCESS JIRA DATA --------------------
def fetch_jira_data(jql):
    response = requests.get(f"{JIRA_URL}{jql}", headers={"Authorization": f"Bearer {JIRA_TOKEN}"})
    return response.json()["issues"] if response.status_code == 200 else []

for version in versions:
    jql3 = f"labels in ({version}) OR Build(s) in ({version})"
    issues = fetch_jira_data(jql3)

    df = pd.DataFrame(issues)[["key", "fields.issuetype.name", "fields.priority.name", "fields.components"]]
    df.columns = ["Issue key", "Issue type", "Priority", "Components"]

    df["Components"] = df["Components"].apply(lambda x: ",".join([comp["name"] for comp in x]) if x else "")
    df["Issue type"] = df.apply(lambda row: f"{row['Issue type']} Security" if "Security" in row["Components"] else row["Issue type"], axis=1)
    df["Issue type"] = df.apply(lambda row: f"{row['Issue type']} P1 High" if "P1 High" in row["Priority"] else row["Issue type"], axis=1)

    df.drop(columns=["Components", "Priority"], inplace=True)
    df.to_excel(f"{DATA_EXCEL_FOLDER}/{version}.xlsx", index=False)

# -------------------- STEP 6: MERGE ALL EXCEL FILES --------------------
merged_df = pd.concat([pd.read_excel(f"{DATA_EXCEL_FOLDER}/{version}.xlsx") for version in versions])
merged_df.insert(3, "Version", [version for version in versions for _ in range(len(merged_df) // len(versions))])
merged_file_path = f"{MERGED_EXCEL_FOLDER}/Merged_{datetime.date.today()}.xlsx"
merged_df.to_excel(merged_file_path, index=False)
print(f"✅ Merged Excel Created: {merged_file_path}")

# -------------------- STEP 7: ASSIGN USERS BASED ON ISSUE TYPE --------------------
issue_type_assignment = {}
for index, row in merged_df.iterrows():
    issue_type = row["Issue type"]
    if issue_type not in issue_type_assignment:
        assigned_user = input(f"Enter the username to assign for issue type '{issue_type}': ")
        issue_type_assignment[issue_type] = assigned_user
    merged_df.at[index, "Assigned to"] = issue_type_assignment[issue_type]

merged_file_path_with_assignment = f"{MERGED_EXCEL_FOLDER}/Merged_Assigned_{datetime.date.today()}.xlsx"
merged_df.to_excel(merged_file_path_with_assignment, index=False)
print(f"✅ Assigned users to each issue type and saved in: {merged_file_path_with_assignment}")

# -------------------- STEP 8: SUMMARY BY ISSUE TYPE --------------------
issue_type_summary = merged_df.groupby("Issue type").size().reset_index(name="Count")
issue_type_summary_file = f"{MERGED_EXCEL_FOLDER}/Issue_Type_Summary_{datetime.date.today()}.xlsx"
issue_type_summary.to_excel(issue_type_summary_file, index=False)
print(f"✅ Summary by Issue Type saved in: {issue_type_summary_file}")

# -------------------- STEP 9: UPLOAD TO DEFECTDOJO --------------------
def upload_to_defectdojo(file_path):
    files = {"file": open(file_path, "rb")}
    response = requests.post(f"{DOJO_URL}/findings", files=files, headers={"Authorization": f"Bearer {DOJO_TOKEN}"})
    if response.status_code == 200:
        print(f"✅ Successfully uploaded: {file_path}")
    else:
        print(f"❌ Upload failed for {file_path}: {response.status_code}")

upload_to_defectdojo(merged_file_path_with_assignment)